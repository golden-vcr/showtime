// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: screening.sql

package queries

import (
	"context"
)

const getCurrentTapeId = `-- name: GetCurrentTapeId :one
select
    (case when screening.ended_at is null
        then screening.tape_id
        else null
    end)::integer as tape_id
from showtime.screening
where screening.broadcast_id = (
    select broadcast.id from showtime.broadcast
    order by broadcast.started_at desc limit 1
)
order by screening.started_at desc limit 1
`

func (q *Queries) GetCurrentTapeId(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, getCurrentTapeId)
	var tape_id int32
	err := row.Scan(&tape_id)
	return tape_id, err
}

const recordScreeningEnded = `-- name: RecordScreeningEnded :exec
update showtime.screening set ended_at = now()
where screening.broadcast_id = $1
    and screening.ended_at is null
`

func (q *Queries) RecordScreeningEnded(ctx context.Context, broadcastID int32) error {
	_, err := q.db.ExecContext(ctx, recordScreeningEnded, broadcastID)
	return err
}

const recordScreeningStarted = `-- name: RecordScreeningStarted :exec
insert into showtime.screening (
    broadcast_id,
    tape_id,
    started_at
) values (
    $1,
    $2,
    now()
)
`

type RecordScreeningStartedParams struct {
	BroadcastID int32
	TapeID      int32
}

func (q *Queries) RecordScreeningStarted(ctx context.Context, arg RecordScreeningStartedParams) error {
	_, err := q.db.ExecContext(ctx, recordScreeningStarted, arg.BroadcastID, arg.TapeID)
	return err
}
